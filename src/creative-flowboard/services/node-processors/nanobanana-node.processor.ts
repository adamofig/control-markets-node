import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { GoogleGenAI } from '@google/genai';
import { ICreativeFlowBoard, IExecutionResult, IJobExecutionState, ITaskExecutionState, NodeType, StatusJob } from '../../models/creative-flowboard.models';
import { INodeProcessor } from './inode.processor';

import { GeneratedAssetService , GeneratedAsset} from '@dataclouder/nest-ai-services-mongodb';

import { IAssetNodeData } from '../../models/nodes.models';
import { FlowsDbStateService } from '../flows-db-state.service';
import { FlowNodeSearchesService } from '../flow-searches.service';

import { CloudStorageService } from '@dataclouder/nest-storage';
import { AiServicesSdkClient } from '@dataclouder/nest-ai-services-sdk';

@Injectable()
export class NanoBananaNodeProcessor implements INodeProcessor {
  private logger = new Logger(NanoBananaNodeProcessor.name);
  private genAI: GoogleGenAI;

  constructor(
    private configService: ConfigService,
    private generatedAssetService: GeneratedAssetService,
    private flowsDbStateService: FlowsDbStateService,
    private cloudStorageService: CloudStorageService,
    private flowNodeSearchesService: FlowNodeSearchesService,
    private clientAIService: AiServicesSdkClient,
  ) {
  }

  async processJob(job: IJobExecutionState, task: ITaskExecutionState, flow: ICreativeFlowBoard): Promise<Partial<IExecutionResult>> {
    this.logger.log(`Processing job: NanoBanana image generation for node ${job.inputNodeId}`);

    const inputNode = flow.nodes.find(n => n.id === job.inputNodeId);

    const imageUrl = inputNode.data.nodeData.storage.url;

    

    const processNode = flow.nodes.find(n => n.id === job.processNodeId);

    if (!processNode) {
      throw new Error(`Process node ${job.processNodeId} not found`);
    }

    const processData = processNode.data?.nodeData || {};
    const prompt = processData.prompt || 'A creative banana-themed image';
    const modelName = processData.model || 'gemini-3.1-flash-image-preview';
    const aspectRatio = processData.aspectRatio || '1:1';
    
    this.logger.verbose(`Prompt: ${prompt}, Model: ${modelName}, Aspect Ratio: ${aspectRatio}`);
    
    // Extract connected asset image nodes to pass their URLs
    const inputNodes = job.inputNodeIds 
      ? flow.nodes.filter(node => job.inputNodeIds.includes(node.id))
      : this.flowNodeSearchesService.getInputNodes(job.processNodeId, flow);
    
    // We can assume first or multiple assets are images we want to pass.
    // Just map all input Assets nodes.
    const assetNodes = inputNodes.filter(node => node.config.component === NodeType.AssetsNodeComponent);
    
    const assetsForGeneration = {};
    assetNodes.forEach((node, index) => {
        const assetNodeData = node.data.nodeData as IAssetNodeData;
        if (assetNodeData?.storage) {
           assetsForGeneration[`inputImage_${index}`] = assetNodeData.storage;
        }
    });

    try {


      // Save the generated asset with extracted references
      const newAsset: Partial<GeneratedAsset> = {
        name: `NanoBanana_${Date.now()}.png`,
        type: 'image' as any,
        prompt: prompt,
        description: `Generated by NanoBanana (${modelName})`,
        provider: 'vertex' as any,
        assets: assetsForGeneration as any,
        metadata: {
          model: modelName,
          aspectRatio: aspectRatio,
          job: {
            flowExecutionId: job.flowExecutionId,
            fatherTaskId: task.id,
            inputNodeId: job.inputNodeId
          }
        }
      };

      const savedAsset = await this.generatedAssetService.save(newAsset);
      
      this.logger.log(`Calling AI Service: Generating image for asset ${savedAsset.id}...`);
      await (this.clientAIService.image as any).generateNanoBananaFromAssetId(savedAsset.id);

      this.logger.log(`DONE Image generation requested via SDK for asset ${savedAsset.id}`);

      return {
        status: StatusJob.COMPLETED,
        outputEntityId: savedAsset.id,
        resultType: 'generatedAsset',
        statusDescription: 'Image generation requested successfully'
      };

    } catch (error) {
      this.logger.error(`Error in NanoBanana processing: ${error.message}`, error.stack);
      return {
        status: StatusJob.FAILED,
        statusDescription: `Gemini Error: ${error.message}`
      };
    }
  }
}
