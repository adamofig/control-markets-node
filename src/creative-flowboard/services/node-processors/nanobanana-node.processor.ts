import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { GoogleGenAI } from '@google/genai';
import { ICreativeFlowBoard, IExecutionResult, IJobExecutionState, ITaskExecutionState, NodeType, StatusJob } from '../../models/creative-flowboard.models';
import { INodeProcessor } from './inode.processor';

import { GeneratedAssetService , GeneratedAsset} from '@dataclouder/nest-ai-services-mongodb';

import { IAssetNodeData } from '../../models/nodes.models';
import { FlowsDbStateService } from '../flows-db-state.service';

import { CloudStorageService } from '@dataclouder/nest-storage';

@Injectable()
export class NanoBananaNodeProcessor implements INodeProcessor {
  private logger = new Logger(NanoBananaNodeProcessor.name);
  private genAI: GoogleGenAI;

  constructor(
    private configService: ConfigService,
    private generatedAssetService: GeneratedAssetService,
    private flowsDbStateService: FlowsDbStateService,
    private cloudStorageService: CloudStorageService,
  ) {
    const apiKey = this.configService.get<string>('GEMINI_API_KEY') || '';
    if (!apiKey) {
      this.logger.error('GEMINI_API_KEY not found in configuration');
    }
    // The SDK provided in the documentation uses an options object, though usually it takes the key.
    // However, the doc example shows new GoogleGenAI({}); which might rely on process.env.GOOGLE_API_KEY
    // I will try to pass it if possible or set it in env.
    // process.env['GOOGLE_API_KEY'] = apiKey;
    this.genAI = new GoogleGenAI({ apiKey: apiKey });
  }

  async processJob(job: IJobExecutionState, task: ITaskExecutionState, flow: ICreativeFlowBoard): Promise<Partial<IExecutionResult>> {
    this.logger.log(`Processing job: NanoBanana image generation for node ${job.inputNodeId}`);

    const inputNode = flow.nodes.find(n => n.id === job.inputNodeId);

    const imageUrl = inputNode.data.nodeData.storage.url;

    

    const processNode = flow.nodes.find(n => n.id === job.processNodeId);

    if (!processNode) {
      throw new Error(`Process node ${job.processNodeId} not found`);
    }

    const processData = processNode.data?.nodeData || {};
    const prompt = processData.prompt || 'A creative banana-themed image';
    const modelName = processData.model || 'gemini-3-pro-image-preview';
    const aspectRatio = processData.aspectRatio || '1:1';
    
    this.logger.verbose(`Prompt: ${prompt}, Model: ${modelName}, Aspect Ratio: ${aspectRatio}`);

    try {


      // Based on documentation: ai.models.generateContent

      const apiKey = this.configService.get<string>('GEMINI_API_KEY') || '';

      const genAI = new GoogleGenAI({ apiKey: apiKey });

      const imageConfig = {
            aspectRatio: aspectRatio,
            imageSize: '1k',
          };

      console.log('Image config:', imageConfig);
      
const response = await genAI.models.generateContent({
    model: modelName,
    contents: [{ text: prompt }],
    config: {
      responseModalities: ['TEXT', 'IMAGE'],
      imageConfig: imageConfig,
    },
  });


      const candidate = response.candidates[0];
      let imageBuffer: Buffer | null = null;

      for (const part of candidate.content.parts) {
        if (part.inlineData) {
          imageBuffer = Buffer.from(part.inlineData.data, 'base64');
          break;
        }
      }

      if (!imageBuffer) {
        throw new Error('No image was generated in the response');
      }

      const fileName = `NanoBanana_${Date.now()}.png`;

      // Upload to cloud storage
      const uploadedFile = await this.cloudStorageService.uploadFile(
          fileName,
          imageBuffer,
          { orgId: flow.orgId } as any,
          'image/png'
      );

      console.log('Uploaded file:', uploadedFile);

      // Save the generated asset
      const newAsset: Partial<GeneratedAsset> = {
        name: fileName,
        type: 'image' as any,
        prompt: prompt,
        description: `Generated by NanoBanana (${modelName})`,
        provider: 'vertex' as any,
        result: uploadedFile,
        url: uploadedFile.url,
        metadata: {
          model: modelName,
          aspectRatio: aspectRatio,
          job: {
            flowExecutionId: job.flowExecutionId,
            fatherTaskId: task.id,
            inputNodeId: job.inputNodeId
          }
        }
      };

      const savedAsset = await this.generatedAssetService.save(newAsset);
      
      // Update the asset with the actual file (this depends on how generatedAssetService works, 
      // usually it might need a upload call if not handled by save)
      // For this implementation, I'll assume saving the metadata and potentially 
      // the system has a background task or another service handles the buffer if passed.
      // If I need to upload to storage:
      // await this.generatedAssetService.uploadBuffer(savedAsset.id, imageBuffer, 'image/png');

      this.logger.log(`Image generated and asset saved: ${savedAsset.id}`);

      return {
        status: StatusJob.COMPLETED,
        outputEntityId: savedAsset.id,
        resultType: 'generatedAsset',
        statusDescription: 'Image generated successfully'
      };

    } catch (error) {
      this.logger.error(`Error in NanoBanana processing: ${error.message}`, error.stack);
      return {
        status: StatusJob.FAILED,
        statusDescription: `Gemini Error: ${error.message}`
      };
    }
  }
}
